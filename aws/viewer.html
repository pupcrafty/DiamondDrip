<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prediction Database Viewer - DiamondDrip</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .api-info {
            margin-bottom: 20px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 4px;
            font-size: 14px;
            color: #555;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .controls button, .controls input, .controls label {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .controls button {
            background: #3498db;
            color: white;
            border: none;
        }
        
        .controls button:hover {
            background: #2980b9;
        }
        
        .controls button.active {
            background: #27ae60;
        }
        
        .controls input[type="number"] {
            width: 80px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 8px;
            font-weight: 400;
        }
        
        .stat-card .value {
            font-size: 32px;
            font-weight: bold;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        
        .status.error {
            background: #fee;
            color: #c33;
            border: 1px solid #fcc;
        }
        
        .status.success {
            background: #efe;
            color: #3c3;
            border: 1px solid #cfc;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
        }
        
        th:hover {
            background: #e9ecef;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .json-field {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .json-field.expanded {
            white-space: pre-wrap;
            max-width: none;
            word-break: break-all;
        }
        
        .json-toggle {
            color: #3498db;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .timestamp {
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .bpm {
            font-weight: 600;
            color: #27ae60;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }
        
        /* Tab styles */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }
        
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            transition: all 0.2s;
        }
        
        .tab:hover {
            color: #3498db;
        }
        
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Pattern view styles */
        .pattern-view {
            margin-top: 20px;
        }
        
        .pattern-item-card {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .pattern-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .pattern-item-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .pattern-item-meta {
            display: flex;
            gap: 15px;
            font-size: 14px;
            color: #666;
        }
        
        .pattern-item-meta .bpm-label {
            font-weight: 600;
            color: #27ae60;
        }
        
        .pattern-grid {
            display: flex;
            gap: 2px;
            align-items: center;
            flex-wrap: wrap;
            background-color: #1a1a24;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .pattern-slot {
            width: 22px;
            height: 45px;
            background-color: #222;
            border: 1px solid #333;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #888;
            position: relative;
        }
        
        .pattern-slot.active {
            background-color: #44ff44;
            color: #000;
            font-weight: 600;
        }
        
        .pattern-slot.beat-start {
            border-color: #666;
            border-width: 2px;
        }
        
        .pattern-slot.beat-start.active {
            background-color: #44cc44;
        }
        
        .pattern-slot.sustained {
            border: 2px solid #ffff00;
            box-shadow: 0 0 6px rgba(255, 255, 0, 0.5);
        }
        
        .pattern-slot.sustained.active {
            background-color: #ffff44;
            color: #000;
            font-size: 9px;
        }
        
        .pattern-slot.sustained.beat-start.active {
            background-color: #ffcc44;
        }
        
        .pattern-slot.sustained:not(.active) {
            background-color: #444422;
        }
        
        .pattern-slot.sustained.beat-start:not(.active) {
            background-color: #664422;
        }
        
        .pattern-legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-box {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 2px;
        }
        
        .legend-box.active {
            background-color: #44ff44;
        }
        
        .legend-box.sustained {
            background-color: #ffff44;
            border-color: #ffff00;
        }
        
        .no-patterns {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Prediction Database Viewer</h1>
        <div class="api-info" id="apiInfo">API Endpoint: <span id="apiEndpoint">Loading...</span></div>
        
        <div class="controls">
            <button id="refreshBtn">Refresh</button>
            <button id="autoRefreshBtn">Auto-refresh: OFF</button>
            <label>
                Limit: <input type="number" id="limitInput" value="100" min="1" max="1000">
            </label>
        </div>
        
        <div id="status" class="status"></div>
        
        <div id="stats" class="stats"></div>
        
        <div class="tabs">
            <button class="tab active" data-tab="table">Table View</button>
            <button class="tab" data-tab="patterns">Beat Patterns</button>
        </div>
        
        <div id="tableTab" class="tab-content active">
            <div id="tableContainer">
                <div class="loading">Loading data...</div>
            </div>
        </div>
        
        <div id="patternsTab" class="tab-content">
            <div id="patternsContainer" class="pattern-view">
                <div class="loading">Loading patterns...</div>
            </div>
        </div>
    </div>
    
    <script>
        // API endpoint will be injected during deployment
        // Fallback: try to detect from URL or use default
        const API_BASE = window.API_ENDPOINT || 'https://le71czez6a.execute-api.us-east-1.amazonaws.com/production';
        
        // Display API endpoint
        document.getElementById('apiEndpoint').textContent = API_BASE;
        
        let autoRefreshInterval = null;
        let currentLimit = 100;
        let sourcesCache = new Map(); // Cache of hashed_ip -> {id, emoji}
        
        async function fetchSources() {
            try {
                const response = await fetch(`${API_BASE}/sources`);
                if (!response.ok) {
                    // If endpoint doesn't exist (404) or server error, use cache
                    if (response.status === 404) {
                        console.warn('[Viewer] /sources endpoint not found - using cached sources if available');
                    } else {
                        console.warn(`[Viewer] Failed to fetch sources: ${response.status} ${response.statusText}`);
                    }
                    return sourcesCache;
                }
                const sources = await response.json();
                sourcesCache.clear();
                sources.forEach(source => {
                    sourcesCache.set(source.hashed_ip, {
                        id: source.id,
                        emoji: source.emoji
                    });
                });
                return sourcesCache;
            } catch (error) {
                // Network errors or CORS errors - use cache silently
                // Only log if cache is empty (first load)
                if (sourcesCache.size === 0) {
                    console.warn('[Viewer] Could not fetch sources (endpoint may not be configured):', error.message);
                }
                return sourcesCache;
            }
        }
        
        function getEmojiForHash(hash) {
            if (!hash || hash === '-') {
                return '❓';
            }
            
            const source = sourcesCache.get(hash);
            if (source) {
                return source.emoji;
            }
            
            // Fallback if not in cache yet
            return '❓';
        }
        
        function showStatus(message, isError = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + (isError ? 'error' : 'success');
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
        
        function formatJSON(str) {
            try {
                const obj = JSON.parse(str);
                return JSON.stringify(obj, null, 2);
            } catch {
                return str;
            }
        }
        
        function formatTimestamp(ts) {
            if (!ts) return '-';
            try {
                const date = new Date(ts);
                return date.toLocaleString();
            } catch {
                return ts;
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeHtmlAttr(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        async function fetchStats() {
            try {
                const response = await fetch(`${API_BASE}/stats`);
                if (!response.ok) throw new Error('Failed to fetch stats');
                const stats = await response.json();
                displayStats(stats);
            } catch (error) {
                console.error('Error fetching stats:', error);
                document.getElementById('stats').innerHTML = '<div class="stat-card"><h3>Error</h3><div class="value">Failed to load</div></div>';
            }
        }
        
        function displayStats(stats) {
            const statsContainer = document.getElementById('stats');
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <h3>Total Predictions</h3>
                    <div class="value">${stats.total_predictions || 0}</div>
                </div>
                <div class="stat-card">
                    <h3>Average BPM</h3>
                    <div class="value">${stats.avg_bpm ? stats.avg_bpm.toFixed(2) : 'N/A'}</div>
                </div>
                <div class="stat-card">
                    <h3>Min BPM</h3>
                    <div class="value">${stats.min_bpm ? stats.min_bpm.toFixed(2) : 'N/A'}</div>
                </div>
                <div class="stat-card">
                    <h3>Max BPM</h3>
                    <div class="value">${stats.max_bpm ? stats.max_bpm.toFixed(2) : 'N/A'}</div>
                </div>
            `;
        }
        
        let cachedPredictions = [];
        
        async function fetchPredictions(limit = 100) {
            try {
                const response = await fetch(`${API_BASE}/recent?limit=${limit}`);
                if (!response.ok) throw new Error('Failed to fetch predictions');
                const predictions = await response.json();
                cachedPredictions = predictions;
                displayPredictions(predictions);
                displayPatterns(predictions);
                showStatus(`Loaded ${predictions.length} predictions`);
            } catch (error) {
                console.error('Error fetching predictions:', error);
                document.getElementById('tableContainer').innerHTML = 
                    '<div class="status error">Failed to load predictions: ' + error.message + '</div>';
                showStatus('Error loading predictions', true);
            }
        }
        
        function displayPredictions(predictions) {
            const container = document.getElementById('tableContainer');
            
            if (predictions.length === 0) {
                container.innerHTML = '<div class="loading">No predictions found</div>';
                return;
            }
            
            // Count predictions per hash
            const hashCounts = new Map();
            predictions.forEach(pred => {
                const hash = pred.hashed_ip || null;
                if (hash) {
                    hashCounts.set(hash, (hashCounts.get(hash) || 0) + 1);
                }
            });
            
            let html = '<table><thead><tr>';
            html += '<th>ID</th>';
            html += '<th>Client Timestamp</th>';
            html += '<th>Server Timestamp</th>';
            html += '<th>BPM</th>';
            html += '<th>Device</th>';
            html += '<th>BPM History</th>';
            html += '<th>Current Prediction</th>';
            html += '<th>Created At</th>';
            html += '</tr></thead><tbody>';
            
            predictions.forEach((pred, index) => {
                const bpmHistoryJson = pred.bpm_history ? formatJSON(pred.bpm_history) : '-';
                const currentPredJson = pred.current_prediction ? formatJSON(pred.current_prediction) : '-';
                const bpmHistoryShort = bpmHistoryJson.length > 50 ? bpmHistoryJson.substring(0, 50) + '...' : bpmHistoryJson;
                const currentPredShort = currentPredJson.length > 50 ? currentPredJson.substring(0, 50) + '...' : currentPredJson;
                
                html += '<tr>';
                html += `<td>${pred.id}</td>`;
                html += `<td class="timestamp">${formatTimestamp(pred.client_timestamp)}</td>`;
                html += `<td class="timestamp">${formatTimestamp(pred.server_timestamp)}</td>`;
                html += `<td class="bpm">${pred.current_bpm ? pred.current_bpm.toFixed(2) : '-'}</td>`;
                const deviceHash = pred.hashed_ip || '-';
                const emoji = getEmojiForHash(deviceHash);
                const count = hashCounts.get(deviceHash) || 0;
                const sourceInfo = sourcesCache.get(deviceHash);
                const sourceId = sourceInfo ? sourceInfo.id : '?';
                html += `<td style="font-size: 18px; text-align: center;" title="Source ID: ${sourceId}, Hash: ${escapeHtmlAttr(deviceHash)}">${emoji} (${count})</td>`;
                if (pred.bpm_history && bpmHistoryJson.length > 50) {
                    html += `<td class="json-field" data-full="${escapeHtmlAttr(bpmHistoryJson)}">${escapeHtml(bpmHistoryShort)}<span class="json-toggle" onclick="toggleJSON(this)"> [show]</span></td>`;
                } else {
                    html += `<td class="json-field">${escapeHtml(bpmHistoryJson)}</td>`;
                }
                if (pred.current_prediction && currentPredJson.length > 50) {
                    html += `<td class="json-field" data-full="${escapeHtmlAttr(currentPredJson)}">${escapeHtml(currentPredShort)}<span class="json-toggle" onclick="toggleJSON(this)"> [show]</span></td>`;
                } else {
                    html += `<td class="json-field">${escapeHtml(currentPredJson)}</td>`;
                }
                html += `<td class="timestamp">${formatTimestamp(pred.created_at)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        function toggleJSON(el) {
            const field = el.parentElement;
            const isExpanded = field.classList.contains('expanded');
            const fullText = field.getAttribute('data-full');
            
            if (isExpanded) {
                field.classList.remove('expanded');
                const shortText = fullText.length > 50 ? fullText.substring(0, 50) + '...' : fullText;
                field.innerHTML = escapeHtml(shortText) + '<span class="json-toggle" onclick="toggleJSON(this)"> [show]</span>';
            } else {
                field.classList.add('expanded');
                const formattedText = escapeHtml(fullText).replace(/\n/g, '<br>');
                field.innerHTML = formattedText + '<span class="json-toggle" onclick="toggleJSON(this)"> [hide]</span>';
            }
        }
        
        async function loadData() {
            await Promise.all([
                fetchStats(),
                fetchSources(),
                fetchPredictions(currentLimit)
            ]);
        }
        
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                btn.textContent = 'Auto-refresh: OFF';
                btn.classList.remove('active');
            } else {
                autoRefreshInterval = setInterval(loadData, 5000);
                btn.textContent = 'Auto-refresh: ON (5s)';
                btn.classList.add('active');
            }
        }
        
        // Event listeners
        document.getElementById('refreshBtn').addEventListener('click', loadData);
        document.getElementById('autoRefreshBtn').addEventListener('click', toggleAutoRefresh);
        document.getElementById('limitInput').addEventListener('change', (e) => {
            currentLimit = parseInt(e.target.value) || 100;
            fetchPredictions(currentLimit);
        });
        
        // Initial load
        loadData();
        
        // Pattern rendering functions
        const PHRASE_BEATS = 4;
        
        function parsePattern(patternJson) {
            if (!patternJson) return null;
            try {
                if (typeof patternJson === 'string') {
                    return JSON.parse(patternJson);
                }
                return patternJson;
            } catch {
                return null;
            }
        }
        
        function parseDurations(durationsJson) {
            if (!durationsJson) return null;
            try {
                if (typeof durationsJson === 'string') {
                    return JSON.parse(durationsJson);
                }
                return durationsJson;
            } catch {
                return null;
            }
        }
        
        function getSustainedBeatCoveredSlots(durations) {
            const coveredSlots = new Set();
            if (!durations || !Array.isArray(durations)) return coveredSlots;
            
            durations.forEach((duration32nd, slot) => {
                if (duration32nd !== null && duration32nd !== undefined && duration32nd > 0) {
                    const slotsToCover = Math.ceil(duration32nd);
                    for (let i = 0; i < slotsToCover; i++) {
                        const coveredSlot = slot + i;
                        if (coveredSlot >= 0 && coveredSlot < PHRASE_BEATS * 8) {
                            coveredSlots.add(coveredSlot);
                        }
                    }
                }
            });
            
            return coveredSlots;
        }
        
        function renderPattern(pattern, durations, bpm) {
            if (!pattern || !Array.isArray(pattern) || pattern.length === 0) {
                return '<div class="no-patterns">No pattern data available</div>';
            }
            
            const sustainedCoveredSlots = getSustainedBeatCoveredSlots(durations);
            
            let html = '<div class="pattern-grid">';
            for (let beat = 0; beat < PHRASE_BEATS; beat++) {
                for (let thirtySecond = 0; thirtySecond < 8; thirtySecond++) {
                    const index = beat * 8 + thirtySecond;
                    const isActive = pattern[index] === true;
                    const isBeatStart = thirtySecond === 0;
                    const duration32nd = durations && durations[index];
                    const isSustained = duration32nd !== null && duration32nd !== undefined && duration32nd > 0;
                    const isCoveredBySustained = sustainedCoveredSlots.has(index);
                    
                    const classes = ['pattern-slot'];
                    if (isActive) classes.push('active');
                    if (isBeatStart) classes.push('beat-start');
                    if (isCoveredBySustained) classes.push('sustained');
                    
                    let displayText = isBeatStart ? (beat + 1) : '';
                    if (isSustained && isActive && duration32nd !== undefined) {
                        displayText = duration32nd.toFixed(1);
                    }
                    
                    const titleText = isSustained && isActive ? `Sustained: ${duration32nd.toFixed(2)} 32nd beats` : 
                                    isCoveredBySustained ? 'Covered by sustained beat' : 
                                    isActive ? 'Pulse' : '';
                    
                    html += `<div class="${classes.join(' ')}" title="${titleText}">${displayText}</div>`;
                }
            }
            html += '</div>';
            
            html += '<div class="pattern-legend">';
            html += '<div class="legend-item"><div class="legend-box active"></div><span>Pulse</span></div>';
            html += '<div class="legend-item"><div class="legend-box sustained"></div><span>Sustained (duration shown)</span></div>';
            html += '<div class="legend-item"><span>Numbers = Beat (1-4) or Duration (32nd notes)</span></div>';
            html += '</div>';
            
            return html;
        }
        
        function displayPatterns(predictions) {
            const container = document.getElementById('patternsContainer');
            
            if (predictions.length === 0) {
                container.innerHTML = '<div class="no-patterns">No predictions found</div>';
                return;
            }
            
            // Filter to only show predictions with pattern data
            const predictionsWithPatterns = predictions.filter(pred => {
                const recentPatterns = parsePattern(pred.recent_pulse_patterns);
                return recentPatterns && recentPatterns.length > 0;
            });
            
            if (predictionsWithPatterns.length === 0) {
                container.innerHTML = '<div class="no-patterns">No patterns found in predictions</div>';
                return;
            }
            
            let html = '';
            
            // Show most recent first
            predictionsWithPatterns.slice(0, 50).forEach((pred, index) => {
                const bpm = pred.current_bpm || null;
                const recentPatterns = parsePattern(pred.recent_pulse_patterns) || [];
                const recentDurations = parsePattern(pred.recent_pulse_durations) || [];
                const currentPrediction = parsePattern(pred.current_prediction) || null;
                const currentPredDurations = parsePattern(pred.current_prediction_durations) || null;
                
                // Show recent pulse patterns (actuals)
                if (recentPatterns.length > 0) {
                    // Show the most recent pattern
                    const mostRecentPattern = recentPatterns[recentPatterns.length - 1];
                    const mostRecentDurations = recentDurations.length > 0 ? recentDurations[recentDurations.length - 1] : null;
                    
                    html += '<div class="pattern-item-card">';
                    html += '<div class="pattern-item-header">';
                    html += `<h3>Recent Actual Pattern #${predictionsWithPatterns.length - index}</h3>`;
                    html += '<div class="pattern-item-meta">';
                    if (bpm) {
                        html += `<span class="bpm-label">BPM: ${bpm.toFixed(2)}</span>`;
                    }
                    html += `<span>ID: ${pred.id}</span>`;
                    html += `<span>${formatTimestamp(pred.created_at)}</span>`;
                    html += '</div>';
                    html += '</div>';
                    html += renderPattern(mostRecentPattern, mostRecentDurations, bpm);
                    html += '</div>';
                }
                
                // Show current prediction (predicted)
                if (currentPrediction && Array.isArray(currentPrediction) && currentPrediction.length > 0) {
                    html += '<div class="pattern-item-card">';
                    html += '<div class="pattern-item-header">';
                    html += `<h3>Predicted Pattern #${predictionsWithPatterns.length - index}</h3>`;
                    html += '<div class="pattern-item-meta">';
                    if (bpm) {
                        html += `<span class="bpm-label">BPM: ${bpm.toFixed(2)}</span>`;
                    }
                    html += `<span>ID: ${pred.id}</span>`;
                    html += `<span>${formatTimestamp(pred.created_at)}</span>`;
                    html += '</div>';
                    html += '</div>';
                    html += renderPattern(currentPrediction, currentPredDurations, bpm);
                    html += '</div>';
                }
            });
            
            container.innerHTML = html;
        }
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.getAttribute('data-tab');
                
                // Update tab buttons
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                if (targetTab === 'table') {
                    document.getElementById('tableTab').classList.add('active');
                } else if (targetTab === 'patterns') {
                    document.getElementById('patternsTab').classList.add('active');
                    // Refresh patterns view if needed
                    if (cachedPredictions.length > 0) {
                        displayPatterns(cachedPredictions);
                    }
                }
            });
        });
        
        // Make toggleJSON available globally
        window.toggleJSON = toggleJSON;
    </script>
</body>
</html>

