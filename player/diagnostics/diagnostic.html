<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prediction Call Diagnostic</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #b0b0b0;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(40, 40, 55, 0.8);
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .card.full-width {
            grid-column: 1 / -1;
        }

        .card h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid rgba(100, 150, 255, 0.5);
            padding-bottom: 8px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 100, 120, 0.2);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: bold;
            color: #b0c4ff;
            flex: 0 0 200px;
        }

        .info-value {
            color: #e0e0e0;
            flex: 1;
            text-align: right;
            word-break: break-all;
        }

        .info-value.null {
            color: #ff6b6b;
            font-style: italic;
        }

        .info-value.valid {
            color: #51cf66;
        }

        .json-display {
            background: #1a1a2e;
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #e0e0e0;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            margin-top: 15px;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-weight: bold;
        }

        .status.success {
            background: rgba(81, 207, 102, 0.2);
            border: 1px solid rgba(81, 207, 102, 0.5);
            color: #51cf66;
        }

        .status.error {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #ff6b6b;
        }

        .status.info {
            background: rgba(100, 180, 255, 0.2);
            border: 1px solid rgba(100, 180, 255, 0.5);
            color: #64b4ff;
        }

        .request-history {
            max-height: 300px;
            overflow-y: auto;
        }

        .request-item {
            background: rgba(30, 30, 45, 0.6);
            border-left: 4px solid #667eea;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .request-item.error {
            border-left-color: #ff6b6b;
        }

        .request-item.success {
            border-left-color: #51cf66;
        }

        .request-time {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 5px;
        }

        .auto-update {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .auto-update label {
            cursor: pointer;
            user-select: none;
        }

        .auto-update input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .url-input {
            width: 100%;
            padding: 10px;
            background: #1a1a2e;
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 8px;
        }

        .badge.ready {
            background: rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }

        .badge.not-ready {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Prediction Call Diagnostic</h1>
        <p class="subtitle">Monitor and test what gets sent to the prediction server</p>
        <div class="status info" style="margin-bottom: 20px; padding: 15px;">
            <strong>Instructions:</strong><br>
            1. Click "Start Listening" to begin collecting audio data (requires microphone permission)<br>
            2. Wait for BPM and prediction data to appear<br>
            3. Review the payload that would be sent to the server<br>
            4. Adjust the server URL if needed (change localhost to your server's IP address)<br>
            5. Click "Send Test Request" to verify the connection works<br>
            6. Check the request history to see responses and verify devices are being tracked correctly
        </div>

        <div class="grid">
            <!-- Connection Info -->
            <div class="card">
                <h2>Connection Info</h2>
                <div class="info-row">
                    <span class="info-label">Server URL:</span>
                    <span class="info-value">
                        <input type="text" id="serverUrl" class="url-input" value="https://localhost:8444/prediction" placeholder="https://localhost:8444/prediction">
                    </span>
                </div>
                <div style="font-size: 0.85em; color: #888; margin-top: 5px;">
                    Change "localhost" to your server's IP address to test from other devices
                </div>
                <div class="info-row">
                    <span class="info-label">Client IP:</span>
                    <span class="info-value" id="clientIp">Detecting...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">User Agent:</span>
                    <span class="info-value" id="userAgent" style="font-size: 0.85em;"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">Device Type:</span>
                    <span class="info-value" id="deviceType"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">Browser:</span>
                    <span class="info-value" id="browser"></span>
                </div>
                <div style="font-size: 0.85em; color: #888; margin-top: 10px; padding: 8px; background: rgba(30,30,45,0.6); border-radius: 4px;">
                    <strong>Note:</strong> The server identifies devices using: IP + Device Type + Browser<br>
                    Different devices/browsers will have different identifiers, allowing the server to count unique sources.
                </div>
            </div>

            <!-- Data Status -->
            <div class="card">
                <h2>Data Status</h2>
                <div class="info-row">
                    <span class="info-label">Current BPM:</span>
                    <span class="info-value" id="currentBPM">
                        <span class="null">No data yet</span>
                    </span>
                </div>
                <div class="info-row">
                    <span class="info-label">Has Prediction:</span>
                    <span class="info-value" id="hasPrediction">
                        <span class="null">No</span>
                    </span>
                </div>
                <div class="info-row">
                    <span class="info-label">BPM History Length:</span>
                    <span class="info-value" id="bpmHistoryLength">0</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Ready to Send:</span>
                    <span class="info-value" id="readyToSend">
                        <span class="null">No</span>
                    </span>
                </div>
                <div style="margin-top: 15px;">
                    <button class="button" id="startListeningBtn">üé§ Start Listening</button>
                    <button class="button" id="stopListeningBtn" disabled>‚èπÔ∏è Stop Listening</button>
                    <button class="button" id="refreshBtn">üîÑ Refresh Data</button>
                    <div class="auto-update" style="margin-top: 10px;">
                        <input type="checkbox" id="autoUpdate" checked>
                        <label for="autoUpdate">Auto-refresh every 500ms</label>
                    </div>
                    <div id="listeningStatus" style="margin-top: 10px;"></div>
                </div>
            </div>

            <!-- Payload Preview -->
            <div class="card full-width">
                <h2>Payload That Would Be Sent <span class="badge" id="payloadBadge">Not Ready</span></h2>
                <div id="payloadDisplay" class="json-display">Waiting for data...</div>
                <button class="button" id="testSendBtn" disabled>üöÄ Send Test Request</button>
                <div id="sendStatus"></div>
            </div>

            <!-- Request History -->
            <div class="card full-width">
                <h2>Request History</h2>
                <div id="requestHistory" class="request-history">
                    <div class="status info">No requests sent yet. Click "Send Test Request" to test the connection.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script src="../beatDetector/js/logger.js"></script>
    <script src="../config/config.js"></script>
    <script src="../beatDetector/js/beatDetection.js"></script>
    <script src="../beatDetector/js/bpmEstimator.js"></script>
    <script src="../beatDetector/js/energyClassifier.js"></script>
    <script src="../beatDetector/js/rhythmPredictor.js"></script>

    <script>
        const PREDICTION_SERVER_URL = 'https://localhost:8444/prediction';
        let requestHistory = [];
        let autoUpdateInterval = null;
        let isInitialized = false;

        // Initialize beat detection
        async function initializeBeatDetection() {
            if (isInitialized) {
                console.log('Beat detection already initialized');
                return;
            }
            
            try {
                // Check if beatDetection is available
                if (typeof window.beatDetection === 'undefined') {
                    showListeningStatus('error', 'beatDetection module not available. Make sure all scripts are loaded.');
                    return;
                }

                showListeningStatus('info', 'Requesting microphone permission...');
                
                await window.beatDetection.initBeatDetection(
                    // onBeat callback
                    (time, rms, threshold, avg) => {
                        if (typeof BPM_ESTIMATOR !== 'undefined') {
                            BPM_ESTIMATOR.addBeat(time);
                            BPM_ESTIMATOR.update();
                        }
                        if (typeof ENERGY_CLASSIFIER !== 'undefined') {
                            ENERGY_CLASSIFIER.addRmsSample(rms);
                            ENERGY_CLASSIFIER.update();
                        }
                        if (typeof RHYTHM_PREDICTOR !== 'undefined' && typeof BPM_ESTIMATOR !== 'undefined') {
                            const hyperBPM = BPM_ESTIMATOR.getHyperSmoothedBPM();
                            if (hyperBPM !== null && hyperBPM > 0) {
                                RHYTHM_PREDICTOR.processPulse(time, hyperBPM);
                            }
                        }
                    },
                    // onDiagnostic callback
                    (data) => {
                        if (typeof ENERGY_CLASSIFIER !== 'undefined' && data.rms !== undefined) {
                            ENERGY_CLASSIFIER.addRmsSample(data.rms);
                            ENERGY_CLASSIFIER.update();
                        }
                        if (typeof BPM_ESTIMATOR !== 'undefined') {
                            BPM_ESTIMATOR.update();
                        }
                    }
                );
                isInitialized = true;
                showListeningStatus('success', '‚úÖ Listening started - collecting audio data...');
                document.getElementById('startListeningBtn').disabled = true;
                document.getElementById('stopListeningBtn').disabled = false;
            } catch (error) {
                console.error('Error initializing beat detection:', error);
                showListeningStatus('error', `Failed to start listening: ${error.message}`);
                isInitialized = false;
            }
        }

        // Stop beat detection
        function stopBeatDetection() {
            try {
                if (typeof window.beatDetection !== 'undefined' && window.beatDetection.stopBeatDetection) {
                    window.beatDetection.stopBeatDetection();
                }
                isInitialized = false;
                showListeningStatus('info', '‚èπÔ∏è Listening stopped');
                document.getElementById('startListeningBtn').disabled = false;
                document.getElementById('stopListeningBtn').disabled = true;
            } catch (error) {
                console.error('Error stopping beat detection:', error);
            }
        }

        // Show listening status
        function showListeningStatus(type, message) {
            const statusDiv = document.getElementById('listeningStatus');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }

        // Get device type from user agent
        function getDeviceType() {
            const ua = navigator.userAgent.toLowerCase();
            if (ua.includes('mobile') || ua.includes('android') || ua.includes('iphone') || ua.includes('ipod')) {
                return 'mobile';
            } else if (ua.includes('tablet') || ua.includes('ipad')) {
                return 'tablet';
            } else if (ua.includes('tv') || ua.includes('smart-tv')) {
                return 'tv';
            }
            return 'desktop';
        }

        // Get browser from user agent (matches server logic)
        function getBrowser() {
            const ua = navigator.userAgent.toLowerCase();
            if (ua.includes('chrome') && !ua.includes('edg')) {
                return 'chrome';
            } else if (ua.includes('firefox')) {
                return 'firefox';
            } else if (ua.includes('safari') && !ua.includes('chrome')) {
                return 'safari';
            } else if (ua.includes('edg')) {
                return 'edge';
            } else if (ua.includes('opera') || ua.includes('opr')) {
                return 'opera';
            } else if (ua.includes('msie') || ua.includes('trident')) {
                return 'ie';
            }
            return 'unknown';
        }

        // Build payload (matches the structure sent to prediction server)
        function buildPayload() {
            try {
                if (typeof BPM_ESTIMATOR === 'undefined' || typeof RHYTHM_PREDICTOR === 'undefined') {
                    return null;
                }

                const hyperBPM = BPM_ESTIMATOR.getHyperSmoothedBPM();
                const hyperPrediction = RHYTHM_PREDICTOR.getHyperPredictedPhrasePattern();

                // Only build payload if we have valid data
                if (hyperBPM === null || hyperBPM <= 0 || hyperPrediction === null) {
                    return null;
                }

                // Get BPM history (last 10 values)
                const bpmHistory = BPM_ESTIMATOR.getHyperSmoothedBPMHistory();
                const recentBpmHistory = bpmHistory ? bpmHistory.slice(-10) : [];

                // Get recent pulse patterns (last 5 phrases)
                const allPhrasePatterns = RHYTHM_PREDICTOR.getPhrasePatterns();
                const recentPulsePatterns = allPhrasePatterns ? allPhrasePatterns.slice(-5) : [];

                // Get recent correct prediction parts (last 5)
                const allCorrectParts = RHYTHM_PREDICTOR.getCorrectPredictionPatterns();
                const recentCorrectPredictionParts = allCorrectParts ? allCorrectParts.slice(-5) : [];

                // Prepare payload (exact structure sent to prediction server)
                const payload = {
                    currentBPM: hyperBPM,
                    bpmHistory: recentBpmHistory,
                    recentPulsePatterns: recentPulsePatterns,
                    recentCorrectPredictionParts: recentCorrectPredictionParts,
                    currentPrediction: hyperPrediction,
                    timestamp: new Date().toISOString()
                };

                return payload;
            } catch (error) {
                console.error('Error building payload:', error);
                return null;
            }
        }

        // Update UI with current data
        function updateUI() {
            // Update connection info
            document.getElementById('userAgent').textContent = navigator.userAgent;
            document.getElementById('deviceType').textContent = getDeviceType();
            document.getElementById('browser').textContent = getBrowser();

            // Try to get client IP (may not work in all environments)
            fetch('https://api.ipify.org?format=json')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('clientIp').textContent = data.ip;
                })
                .catch(() => {
                    document.getElementById('clientIp').textContent = 'Unable to detect';
                });

            // Update data status
            let currentBPM = null;
            let hasPrediction = false;
            let bpmHistoryLength = 0;

            if (typeof BPM_ESTIMATOR !== 'undefined') {
                currentBPM = BPM_ESTIMATOR.getHyperSmoothedBPM();
                const bpmHistory = BPM_ESTIMATOR.getHyperSmoothedBPMHistory();
                bpmHistoryLength = bpmHistory ? bpmHistory.length : 0;
            }

            if (typeof RHYTHM_PREDICTOR !== 'undefined') {
                const hyperPrediction = RHYTHM_PREDICTOR.getHyperPredictedPhrasePattern();
                hasPrediction = hyperPrediction !== null;
            }

            // Update BPM display
            const bpmElement = document.getElementById('currentBPM');
            if (currentBPM !== null && currentBPM > 0) {
                bpmElement.innerHTML = `<span class="valid">${currentBPM.toFixed(2)}</span>`;
            } else {
                bpmElement.innerHTML = '<span class="null">No data yet</span>';
            }

            // Update prediction status
            const predictionElement = document.getElementById('hasPrediction');
            if (hasPrediction) {
                predictionElement.innerHTML = '<span class="valid">Yes</span>';
            } else {
                predictionElement.innerHTML = '<span class="null">No</span>';
            }

            // Update BPM history length
            document.getElementById('bpmHistoryLength').textContent = bpmHistoryLength;

            // Update ready to send status
            const payload = buildPayload();
            const readyToSend = payload !== null;
            const readyElement = document.getElementById('readyToSend');
            if (readyToSend) {
                readyElement.innerHTML = '<span class="valid">Yes</span>';
            } else {
                readyElement.innerHTML = '<span class="null">No</span>';
            }

            // Update payload display
            const payloadDisplay = document.getElementById('payloadDisplay');
            const payloadBadge = document.getElementById('payloadBadge');
            const testSendBtn = document.getElementById('testSendBtn');

            if (payload !== null) {
                payloadDisplay.textContent = JSON.stringify(payload, null, 2);
                payloadBadge.textContent = 'Ready';
                payloadBadge.className = 'badge ready';
                testSendBtn.disabled = false;
            } else {
                payloadDisplay.textContent = 'Waiting for valid data...\n\nRequired:\n- currentBPM > 0\n- currentPrediction (not null)';
                payloadBadge.textContent = 'Not Ready';
                payloadBadge.className = 'badge not-ready';
                testSendBtn.disabled = true;
            }
        }

        // Send test request
        async function sendTestRequest() {
            const payload = buildPayload();
            if (!payload) {
                showStatus('error', 'Cannot send: No valid data available');
                return;
            }

            const url = document.getElementById('serverUrl').value;
            const timestamp = new Date().toISOString();

            showStatus('info', 'Sending request...');

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });

                const responseText = await response.text();
                const responseData = response.ok ? JSON.parse(responseText) : null;

                const historyItem = {
                    timestamp: timestamp,
                    success: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    request: payload,
                    response: response.ok ? responseData : { error: responseText },
                    url: url
                };

                requestHistory.unshift(historyItem);
                if (requestHistory.length > 20) {
                    requestHistory = requestHistory.slice(0, 20);
                }

                updateRequestHistory();

                if (response.ok) {
                    showStatus('success', `Request sent successfully! Status: ${response.status}`);
                    if (responseData.avg_bpm_last_20s !== null && responseData.avg_bpm_last_20s !== undefined) {
                        showStatus('success', `Server returned avg_bpm_last_20s: ${responseData.avg_bpm_last_20s.toFixed(2)}`);
                    }
                } else {
                    showStatus('error', `Request failed! Status: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                const historyItem = {
                    timestamp: timestamp,
                    success: false,
                    error: error.message,
                    request: payload,
                    url: url
                };

                requestHistory.unshift(historyItem);
                if (requestHistory.length > 20) {
                    requestHistory = requestHistory.slice(0, 20);
                }

                updateRequestHistory();
                showStatus('error', `Request failed: ${error.message}`);
            }
        }

        // Show status message
        function showStatus(type, message) {
            const statusDiv = document.getElementById('sendStatus');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }

        // Update request history display
        function updateRequestHistory() {
            const historyDiv = document.getElementById('requestHistory');
            if (requestHistory.length === 0) {
                historyDiv.innerHTML = '<div class="status info">No requests sent yet.</div>';
                return;
            }

            historyDiv.innerHTML = requestHistory.map((item, index) => {
                const time = new Date(item.timestamp).toLocaleTimeString();
                const itemClass = item.success ? 'success' : 'error';
                let content = `
                    <div class="request-item ${itemClass}">
                        <div class="request-time">${time} - ${item.url}</div>
                `;

                if (item.error) {
                    content += `<div><strong>Error:</strong> ${item.error}</div>`;
                } else {
                    content += `<div><strong>Status:</strong> ${item.status} ${item.statusText || ''}</div>`;
                }

                if (item.response && item.response.avg_bpm_last_20s !== undefined) {
                    content += `<div><strong>Server avg_bpm_last_20s:</strong> ${item.response.avg_bpm_last_20s}</div>`;
                }

                content += `</div>`;
                return content;
            }).join('');
        }

        // Event listeners
        document.getElementById('refreshBtn').addEventListener('click', updateUI);
        document.getElementById('testSendBtn').addEventListener('click', sendTestRequest);
        document.getElementById('startListeningBtn').addEventListener('click', initializeBeatDetection);
        document.getElementById('stopListeningBtn').addEventListener('click', stopBeatDetection);

        document.getElementById('autoUpdate').addEventListener('change', (e) => {
            if (e.target.checked) {
                autoUpdateInterval = setInterval(updateUI, 500);
            } else {
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                }
            }
        });

        // Initialize
        window.addEventListener('load', async () => {
            updateUI();
            if (document.getElementById('autoUpdate').checked) {
                autoUpdateInterval = setInterval(updateUI, 500);
            }
            showListeningStatus('info', 'Click "Start Listening" to begin collecting audio data');
        });

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (autoUpdateInterval) {
                clearInterval(autoUpdateInterval);
            }
        });
    </script>
</body>
</html>

