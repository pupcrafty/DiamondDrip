<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prediction Call Diagnostic</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #b0b0b0;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(40, 40, 55, 0.8);
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .card.full-width {
            grid-column: 1 / -1;
        }

        .card h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid rgba(100, 150, 255, 0.5);
            padding-bottom: 8px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 100, 120, 0.2);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: bold;
            color: #b0c4ff;
            flex: 0 0 200px;
        }

        .info-value {
            color: #e0e0e0;
            flex: 1;
            text-align: right;
            word-break: break-all;
        }

        .info-value.null {
            color: #ff6b6b;
            font-style: italic;
        }

        .info-value.valid {
            color: #51cf66;
        }

        .json-display {
            background: #1a1a2e;
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #e0e0e0;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            margin-top: 15px;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-weight: bold;
        }

        .status.success {
            background: rgba(81, 207, 102, 0.2);
            border: 1px solid rgba(81, 207, 102, 0.5);
            color: #51cf66;
        }

        .status.error {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #ff6b6b;
        }

        .status.info {
            background: rgba(100, 180, 255, 0.2);
            border: 1px solid rgba(100, 180, 255, 0.5);
            color: #64b4ff;
        }

        .request-history {
            max-height: 300px;
            overflow-y: auto;
        }

        .request-item {
            background: rgba(30, 30, 45, 0.6);
            border-left: 4px solid #667eea;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .request-item.error {
            border-left-color: #ff6b6b;
        }

        .request-item.success {
            border-left-color: #51cf66;
        }

        .request-time {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 5px;
        }

        .auto-update {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .auto-update label {
            cursor: pointer;
            user-select: none;
        }

        .auto-update input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .url-input {
            width: 100%;
            padding: 10px;
            background: #1a1a2e;
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 8px;
        }

        .badge.ready {
            background: rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }

        .badge.not-ready {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Prediction Call Diagnostic</h1>
        <p class="subtitle">Monitor and test what gets sent to the prediction server</p>
        <div class="status info" style="margin-bottom: 20px; padding: 15px;">
            <strong>Instructions:</strong><br>
            1. Click "Start Listening" to begin collecting audio data (requires microphone permission)<br>
            2. Wait for BPM and prediction data to appear<br>
            3. Review the payload that would be sent to the server<br>
            4. Adjust the server URL if needed (change localhost to your server's IP address)<br>
            5. Click "Send Test Request" to verify the connection works<br>
            6. Check the request history to see responses and verify devices are being tracked correctly
        </div>

        <div class="grid">
            <!-- Connection Info -->
            <div class="card">
                <h2>Connection Info</h2>
                <div class="info-row">
                    <span class="info-label">Server URL:</span>
                    <span class="info-value">
                        <input type="text" id="serverUrl" class="url-input" value="https://localhost:8444/prediction" placeholder="https://localhost:8444/prediction">
                    </span>
                </div>
                <div style="font-size: 0.85em; color: #888; margin-top: 5px;">
                    Change "localhost" to your server's IP address to test from other devices
                </div>
                <div class="info-row">
                    <span class="info-label">Client IP:</span>
                    <span class="info-value" id="clientIp">Detecting...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">User Agent:</span>
                    <span class="info-value" id="userAgent" style="font-size: 0.85em;"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">Device Type:</span>
                    <span class="info-value" id="deviceType"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">Browser:</span>
                    <span class="info-value" id="browser"></span>
                </div>
                <div style="font-size: 0.85em; color: #888; margin-top: 10px; padding: 8px; background: rgba(30,30,45,0.6); border-radius: 4px;">
                    <strong>Note:</strong> The server identifies devices using: IP + Device Type + Browser<br>
                    Different devices/browsers will have different identifiers, allowing the server to count unique sources.
                </div>
            </div>

            <!-- Data Status -->
            <div class="card">
                <h2>Data Status</h2>
                <div class="info-row">
                    <span class="info-label">Current BPM:</span>
                    <span class="info-value" id="currentBPM">
                        <span class="null">No data yet</span>
                    </span>
                </div>
                <div class="info-row">
                    <span class="info-label">Has Prediction:</span>
                    <span class="info-value" id="hasPrediction">
                        <span class="null">No</span>
                    </span>
                </div>
                <div class="info-row">
                    <span class="info-label">BPM History Length:</span>
                    <span class="info-value" id="bpmHistoryLength">0</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Ready to Send:</span>
                    <span class="info-value" id="readyToSend">
                        <span class="null">No</span>
                    </span>
                </div>
                <div style="margin-top: 15px;">
                    <button class="button" id="startListeningBtn">üé§ Start Listening</button>
                    <button class="button" id="stopListeningBtn" disabled>‚èπÔ∏è Stop Listening</button>
                    <button class="button" id="refreshBtn">üîÑ Refresh Data</button>
                    <div class="auto-update" style="margin-top: 10px;">
                        <input type="checkbox" id="autoUpdate" checked>
                        <label for="autoUpdate">Auto-refresh every 500ms</label>
                    </div>
                    <div id="listeningStatus" style="margin-top: 10px;"></div>
                </div>
            </div>

            <!-- Payload Preview -->
            <div class="card full-width">
                <h2>Payload That Would Be Sent <span class="badge" id="payloadBadge">Not Ready</span></h2>
                <div id="payloadDisplay" class="json-display">Waiting for data...</div>
                <button class="button" id="testSendBtn" disabled>üöÄ Send Test Request</button>
                <div id="sendStatus"></div>
            </div>

            <!-- Request History -->
            <div class="card full-width">
                <h2>Request History</h2>
                <div id="requestHistory" class="request-history">
                    <div class="status info">No requests sent yet. Click "Send Test Request" to test the connection.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script src="../beatDetector/js/logger.js"></script>
    <script src="../config/config.js"></script>
    <script src="../beatDetector/js/beatDetection.js"></script>
    <script src="../beatDetector/js/bpmEstimator.js"></script>
    <script src="../beatDetector/js/energyClassifier.js"></script>
    <script src="../beatDetector/js/rhythmPredictor.js"></script>

    <script>
        const PREDICTION_SERVER_URL = 'https://localhost:8444/prediction';
        let requestHistory = [];
        let autoUpdateInterval = null;
        let isInitialized = false;
        let serverIP = null; // Cache the server IP

        // Get server IP from current page hostname (if not localhost)
        function getServerIP() {
            if (serverIP) {
                return serverIP;
            }
            
            const hostname = window.location.hostname;
            
            // If page was loaded from an IP address (not localhost), use that
            if (hostname && hostname !== 'localhost' && hostname !== '127.0.0.1') {
                // Check if it's a valid IP address
                const ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
                if (ipPattern.test(hostname)) {
                    serverIP = hostname;
                    return serverIP;
                }
                // If it's a hostname, try to resolve it (but we'll use it as-is for now)
                serverIP = hostname;
                return serverIP;
            }
            
            return null;
        }

        // Replace localhost with server IP in a URL
        function replaceLocalhostWithIP(url) {
            const serverIP = getServerIP();
            if (serverIP && url.includes('localhost')) {
                return url.replace(/localhost/g, serverIP);
            }
            return url;
        }

        // Get the best URL to use (IP if available, otherwise original)
        function getBestServerURL(originalUrl) {
            const serverIP = getServerIP();
            if (serverIP && originalUrl.includes('localhost')) {
                return replaceLocalhostWithIP(originalUrl);
            }
            return originalUrl;
        }

        // Initialize beat detection
        async function initializeBeatDetection() {
            if (isInitialized) {
                console.log('Beat detection already initialized');
                return;
            }
            
            try {
                // Check if beatDetection is available
                if (typeof window.beatDetection === 'undefined') {
                    showListeningStatus('error', 'beatDetection module not available. Make sure all scripts are loaded.');
                    return;
                }

                showListeningStatus('info', 'Requesting microphone permission...');
                
                await window.beatDetection.initBeatDetection(
                    // onBeat callback
                    (time, rms, threshold, avg) => {
                        if (typeof BPM_ESTIMATOR !== 'undefined') {
                            BPM_ESTIMATOR.addBeat(time);
                            BPM_ESTIMATOR.update();
                        }
                        if (typeof ENERGY_CLASSIFIER !== 'undefined') {
                            ENERGY_CLASSIFIER.addRmsSample(rms);
                            ENERGY_CLASSIFIER.update();
                        }
                        if (typeof RHYTHM_PREDICTOR !== 'undefined' && typeof BPM_ESTIMATOR !== 'undefined') {
                            const hyperBPM = BPM_ESTIMATOR.getHyperSmoothedBPM();
                            if (hyperBPM !== null && hyperBPM > 0) {
                                RHYTHM_PREDICTOR.processPulse(time, hyperBPM);
                            }
                        }
                    },
                    // onDiagnostic callback
                    (data) => {
                        if (typeof ENERGY_CLASSIFIER !== 'undefined' && data.rms !== undefined) {
                            ENERGY_CLASSIFIER.addRmsSample(data.rms);
                            ENERGY_CLASSIFIER.update();
                        }
                        if (typeof BPM_ESTIMATOR !== 'undefined') {
                            BPM_ESTIMATOR.update();
                        }
                    }
                );
                isInitialized = true;
                showListeningStatus('success', '‚úÖ Listening started - collecting audio data...');
                document.getElementById('startListeningBtn').disabled = true;
                document.getElementById('stopListeningBtn').disabled = false;
            } catch (error) {
                console.error('Error initializing beat detection:', error);
                showListeningStatus('error', `Failed to start listening: ${error.message}`);
                isInitialized = false;
            }
        }

        // Stop beat detection
        function stopBeatDetection() {
            try {
                if (typeof window.beatDetection !== 'undefined' && window.beatDetection.stopBeatDetection) {
                    window.beatDetection.stopBeatDetection();
                }
                isInitialized = false;
                showListeningStatus('info', '‚èπÔ∏è Listening stopped');
                document.getElementById('startListeningBtn').disabled = false;
                document.getElementById('stopListeningBtn').disabled = true;
            } catch (error) {
                console.error('Error stopping beat detection:', error);
            }
        }

        // Show listening status
        function showListeningStatus(type, message) {
            const statusDiv = document.getElementById('listeningStatus');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }

        // Get device type from user agent
        function getDeviceType() {
            const ua = navigator.userAgent.toLowerCase();
            if (ua.includes('mobile') || ua.includes('android') || ua.includes('iphone') || ua.includes('ipod')) {
                return 'mobile';
            } else if (ua.includes('tablet') || ua.includes('ipad')) {
                return 'tablet';
            } else if (ua.includes('tv') || ua.includes('smart-tv')) {
                return 'tv';
            }
            return 'desktop';
        }

        // Get browser from user agent (matches server logic)
        function getBrowser() {
            const ua = navigator.userAgent.toLowerCase();
            if (ua.includes('chrome') && !ua.includes('edg')) {
                return 'chrome';
            } else if (ua.includes('firefox')) {
                return 'firefox';
            } else if (ua.includes('safari') && !ua.includes('chrome')) {
                return 'safari';
            } else if (ua.includes('edg')) {
                return 'edge';
            } else if (ua.includes('opera') || ua.includes('opr')) {
                return 'opera';
            } else if (ua.includes('msie') || ua.includes('trident')) {
                return 'ie';
            }
            return 'unknown';
        }

        // Build payload (matches the structure sent to prediction server)
        function buildPayload() {
            try {
                if (typeof BPM_ESTIMATOR === 'undefined' || typeof RHYTHM_PREDICTOR === 'undefined') {
                    return null;
                }

                const hyperBPM = BPM_ESTIMATOR.getHyperSmoothedBPM();
                const hyperPrediction = RHYTHM_PREDICTOR.getHyperPredictedPhrasePattern();

                // Only build payload if we have valid data
                if (hyperBPM === null || hyperBPM <= 0 || hyperPrediction === null) {
                    return null;
                }

                // Get BPM history (last 10 values)
                const bpmHistory = BPM_ESTIMATOR.getHyperSmoothedBPMHistory();
                const recentBpmHistory = bpmHistory ? bpmHistory.slice(-10) : [];

                // Get recent pulse patterns (last 5 phrases)
                const allPhrasePatterns = RHYTHM_PREDICTOR.getPhrasePatterns();
                const recentPulsePatterns = allPhrasePatterns ? allPhrasePatterns.slice(-5) : [];

                // Get recent correct prediction parts (last 5)
                const allCorrectParts = RHYTHM_PREDICTOR.getCorrectPredictionPatterns();
                const recentCorrectPredictionParts = allCorrectParts ? allCorrectParts.slice(-5) : [];

                // Prepare payload (exact structure sent to prediction server)
                const payload = {
                    currentBPM: hyperBPM,
                    bpmHistory: recentBpmHistory,
                    recentPulsePatterns: recentPulsePatterns,
                    recentCorrectPredictionParts: recentCorrectPredictionParts,
                    currentPrediction: hyperPrediction,
                    timestamp: new Date().toISOString()
                };

                return payload;
            } catch (error) {
                console.error('Error building payload:', error);
                return null;
            }
        }

        // Update UI with current data
        function updateUI() {
            // Update connection info
            document.getElementById('userAgent').textContent = navigator.userAgent;
            document.getElementById('deviceType').textContent = getDeviceType();
            document.getElementById('browser').textContent = getBrowser();

            // Try to get client IP (may not work in all environments)
            fetch('https://api.ipify.org?format=json')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('clientIp').textContent = data.ip;
                })
                .catch(() => {
                    document.getElementById('clientIp').textContent = 'Unable to detect';
                });

            // Update data status
            let currentBPM = null;
            let hasPrediction = false;
            let bpmHistoryLength = 0;

            if (typeof BPM_ESTIMATOR !== 'undefined') {
                currentBPM = BPM_ESTIMATOR.getHyperSmoothedBPM();
                const bpmHistory = BPM_ESTIMATOR.getHyperSmoothedBPMHistory();
                bpmHistoryLength = bpmHistory ? bpmHistory.length : 0;
            }

            if (typeof RHYTHM_PREDICTOR !== 'undefined') {
                const hyperPrediction = RHYTHM_PREDICTOR.getHyperPredictedPhrasePattern();
                hasPrediction = hyperPrediction !== null;
            }

            // Update BPM display
            const bpmElement = document.getElementById('currentBPM');
            if (currentBPM !== null && currentBPM > 0) {
                bpmElement.innerHTML = `<span class="valid">${currentBPM.toFixed(2)}</span>`;
            } else {
                bpmElement.innerHTML = '<span class="null">No data yet</span>';
            }

            // Update prediction status
            const predictionElement = document.getElementById('hasPrediction');
            if (hasPrediction) {
                predictionElement.innerHTML = '<span class="valid">Yes</span>';
            } else {
                predictionElement.innerHTML = '<span class="null">No</span>';
            }

            // Update BPM history length
            document.getElementById('bpmHistoryLength').textContent = bpmHistoryLength;

            // Update ready to send status
            const payload = buildPayload();
            const readyToSend = payload !== null;
            const readyElement = document.getElementById('readyToSend');
            if (readyToSend) {
                readyElement.innerHTML = '<span class="valid">Yes</span>';
            } else {
                readyElement.innerHTML = '<span class="null">No</span>';
            }

            // Update payload display
            const payloadDisplay = document.getElementById('payloadDisplay');
            const payloadBadge = document.getElementById('payloadBadge');
            const testSendBtn = document.getElementById('testSendBtn');

            if (payload !== null) {
                payloadDisplay.textContent = JSON.stringify(payload, null, 2);
                payloadBadge.textContent = 'Ready';
                payloadBadge.className = 'badge ready';
                testSendBtn.disabled = false;
            } else {
                payloadDisplay.textContent = 'Waiting for valid data...\n\nRequired:\n- currentBPM > 0\n- currentPrediction (not null)';
                payloadBadge.textContent = 'Not Ready';
                payloadBadge.className = 'badge not-ready';
                testSendBtn.disabled = true;
            }
        }

        // Send test request with automatic localhost -> IP retry
        async function sendTestRequest() {
            const payload = buildPayload();
            if (!payload) {
                showStatus('error', 'Cannot send: No valid data available');
                return;
            }

            let url = document.getElementById('serverUrl').value;
            const timestamp = new Date().toISOString();
            let triedIP = false;
            const originalUrl = url;

            showStatus('info', 'Sending request...');

            // Helper function to perform the actual fetch
            async function performFetch(targetUrl) {
                return await fetch(targetUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
            }

            try {
                let response;
                try {
                    // Try with original URL first
                    response = await performFetch(url);
                } catch (firstError) {
                    // If localhost fails and we haven't tried IP yet, retry with IP
                    if (url.includes('localhost') && !triedIP && getServerIP()) {
                        const ipUrl = replaceLocalhostWithIP(url);
                        if (ipUrl !== url) {
                            triedIP = true;
                            url = ipUrl;
                            showStatus('info', `localhost failed, retrying with IP: ${getServerIP()}...`);
                            console.log(`Request to localhost failed, retrying with IP: ${ipUrl}`);
                            
                            // Update the URL input field
                            document.getElementById('serverUrl').value = ipUrl;
                            
                            // Retry with IP
                            response = await performFetch(ipUrl);
                        } else {
                            throw firstError;
                        }
                    } else {
                        throw firstError;
                    }
                }

                const responseText = await response.text();
                let responseData = null;
                try {
                    responseData = response.ok ? JSON.parse(responseText) : null;
                } catch (parseError) {
                    console.warn('Failed to parse response as JSON:', parseError);
                }

                const historyItem = {
                    timestamp: timestamp,
                    success: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    request: payload,
                    response: response.ok ? responseData : { error: responseText, rawResponse: responseText.substring(0, 500) },
                    url: url, // This will be the actual URL used (IP if retried)
                    originalUrl: triedIP ? originalUrl : null, // Track if we switched from localhost
                    responseHeaders: {}
                };

                // Capture response headers for debugging
                try {
                    response.headers.forEach((value, key) => {
                        historyItem.responseHeaders[key] = value;
                    });
                } catch (headerError) {
                    console.warn('Could not read response headers:', headerError);
                }

                requestHistory.unshift(historyItem);
                if (requestHistory.length > 20) {
                    requestHistory = requestHistory.slice(0, 20);
                }

                updateRequestHistory();

                if (response.ok) {
                    showStatus('success', `Request sent successfully! Status: ${response.status}`);
                    if (responseData && responseData.avg_bpm_last_20s !== null && responseData.avg_bpm_last_20s !== undefined) {
                        showStatus('success', `Server returned avg_bpm_last_20s: ${responseData.avg_bpm_last_20s.toFixed(2)}`);
                    }
                } else {
                    let errorMsg = `Request failed! Status: ${response.status} ${response.statusText}`;
                    if (responseText && responseText.length > 0) {
                        const preview = responseText.length > 100 ? responseText.substring(0, 100) + '...' : responseText;
                        errorMsg += `\nResponse: ${preview}`;
                    }
                    showStatus('error', errorMsg);
                    console.error('Prediction request failed with status:', {
                        status: response.status,
                        statusText: response.statusText,
                        responseText: responseText,
                        url: url,
                        timestamp: timestamp
                    });
                }
            } catch (error) {
                // If we haven't tried IP yet and this is a network error with localhost, try IP
                if (!triedIP && url.includes('localhost') && getServerIP()) {
                    const ipUrl = replaceLocalhostWithIP(url);
                    if (ipUrl !== url) {
                        triedIP = true;
                        url = ipUrl;
                        showStatus('info', `localhost failed, retrying with IP: ${getServerIP()}...`);
                        console.log(`Request to localhost failed, retrying with IP: ${ipUrl}`);
                        
                        // Update the URL input field
                        document.getElementById('serverUrl').value = ipUrl;
                        
                        // Retry with IP
                        try {
                            const response = await performFetch(ipUrl);
                            const responseText = await response.text();
                            let responseData = null;
                            try {
                                responseData = response.ok ? JSON.parse(responseText) : null;
                            } catch (parseError) {
                                console.warn('Failed to parse response as JSON:', parseError);
                            }

                            const historyItem = {
                                timestamp: timestamp,
                                success: response.ok,
                                status: response.status,
                                statusText: response.statusText,
                                request: payload,
                                response: response.ok ? responseData : { error: responseText, rawResponse: responseText.substring(0, 500) },
                                url: ipUrl,
                                originalUrl: originalUrl,
                                responseHeaders: {}
                            };

                            // Capture response headers for debugging
                            try {
                                response.headers.forEach((value, key) => {
                                    historyItem.responseHeaders[key] = value;
                                });
                            } catch (headerError) {
                                console.warn('Could not read response headers:', headerError);
                            }

                            requestHistory.unshift(historyItem);
                            if (requestHistory.length > 20) {
                                requestHistory = requestHistory.slice(0, 20);
                            }

                            updateRequestHistory();

                            if (response.ok) {
                                showStatus('success', `Request sent successfully with IP! Status: ${response.status}`);
                                if (responseData && responseData.avg_bpm_last_20s !== null && responseData.avg_bpm_last_20s !== undefined) {
                                    showStatus('success', `Server returned avg_bpm_last_20s: ${responseData.avg_bpm_last_20s.toFixed(2)}`);
                                }
                                return; // Success, exit function
                            } else {
                                let errorMsg = `Request failed with IP! Status: ${response.status} ${response.statusText}`;
                                if (responseText && responseText.length > 0) {
                                    const preview = responseText.length > 100 ? responseText.substring(0, 100) + '...' : responseText;
                                    errorMsg += `\nResponse: ${preview}`;
                                }
                                showStatus('error', errorMsg);
                                console.error('Prediction request failed with status:', {
                                    status: response.status,
                                    statusText: response.statusText,
                                    responseText: responseText,
                                    url: ipUrl,
                                    timestamp: timestamp
                                });
                                return; // Exit after showing error
                            }
                        } catch (retryError) {
                            // Retry also failed, fall through to error handling below
                            error = retryError;
                        }
                    }
                }

                // Build detailed error information
                const errorDetails = {
                    message: error.message || 'Unknown error',
                    name: error.name || 'Error',
                    type: error.constructor?.name || 'Error',
                    stack: error.stack || null
                };

                // Add network-specific error details
                const isNetworkError = error.name === 'TypeError' && (
                    error.message.includes('fetch') || 
                    error.message.includes('Failed to fetch') ||
                    error.message.includes('Load failed') ||
                    error.message.includes('NetworkError')
                );
                
                // Check for SSL/certificate issues
                // TypeError with "Load failed" or "Failed to fetch" on HTTPS usually means SSL certificate issue
                const isSSLError = url.startsWith('https://') && (
                    error.message.includes('certificate') ||
                    error.message.includes('SSL') ||
                    error.message.includes('TLS') ||
                    error.message.includes('ERR_CERT') ||
                    error.message.includes('net::ERR_CERT') ||
                    (error.name === 'TypeError' && (
                        error.message.includes('Load failed') ||
                        error.message.includes('Failed to fetch') ||
                        error.message.toLowerCase().includes('networkerror')
                    ))
                );
                
                if (isNetworkError || isSSLError) {
                    if (isSSLError || (url.startsWith('https://') && isNetworkError)) {
                        errorDetails.networkError = 'SSL Certificate Error - HTTPS request blocked';
                        errorDetails.networkErrorDetails = [
                            'The server is using a self-signed SSL certificate',
                            'Browsers block HTTPS requests with invalid certificates for security',
                            'Solutions:',
                            '  1. Accept the certificate first:',
                            '     - Open this URL in a new tab: ' + url,
                            '     - Click "Advanced" ‚Üí "Proceed to site" (or similar)',
                            '     - Then try the request again',
                            '  2. Note: The server only supports HTTPS, not HTTP',
                            '  3. This is normal for development - the certificate is self-signed'
                        ];
                        errorDetails.isSSLError = true;
                    } else {
                        errorDetails.networkError = 'Network request failed - possible causes:';
                        errorDetails.networkErrorDetails = [
                            'Server is not running on port 8444',
                            'CORS policy blocking the request',
                            'Network connectivity problem',
                            'Firewall blocking the connection',
                            'Wrong port number'
                        ];
                    }
                    
                    // Add note about IP retry if we tried it
                    if (triedIP) {
                        errorDetails.networkErrorDetails.push(`‚úì Auto-switched from localhost to IP (${getServerIP()})`);
                    } else if (url.includes('localhost') && !getServerIP()) {
                        errorDetails.networkErrorDetails.push('Note: Page loaded from localhost, cannot auto-detect server IP');
                    }
                }

                // Add URL validation details
                try {
                    const urlObj = new URL(url);
                    errorDetails.urlDetails = {
                        protocol: urlObj.protocol,
                        hostname: urlObj.hostname,
                        port: urlObj.port || (urlObj.protocol === 'https:' ? '443' : '80'),
                        pathname: urlObj.pathname
                    };
                } catch (urlError) {
                    errorDetails.urlDetails = { error: 'Invalid URL format' };
                }

                // Add payload details
                errorDetails.payloadSize = JSON.stringify(payload).length;
                errorDetails.payloadKeys = Object.keys(payload);

                const historyItem = {
                    timestamp: timestamp,
                    success: false,
                    error: errorDetails.message,
                    errorDetails: errorDetails,
                    request: payload,
                    url: url, // This will be the actual URL used (IP if retried)
                    originalUrl: triedIP ? originalUrl : null // Track if we switched from localhost
                };

                requestHistory.unshift(historyItem);
                if (requestHistory.length > 20) {
                    requestHistory = requestHistory.slice(0, 20);
                }

                updateRequestHistory();
                
                // Show detailed error message
                let errorMessage = `Request failed: ${errorDetails.message}`;
                if (errorDetails.name) {
                    errorMessage += ` (${errorDetails.name})`;
                }
                if (errorDetails.networkError) {
                    errorMessage += `\n${errorDetails.networkError}`;
                }
                showStatus('error', errorMessage);
                
                // Log full error details to console
                console.error('Prediction request failed:', {
                    error: errorDetails,
                    url: url,
                    payloadSize: errorDetails.payloadSize,
                    timestamp: timestamp
                });
            }
        }

        // Show status message
        function showStatus(type, message) {
            const statusDiv = document.getElementById('sendStatus');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }

        // Update request history display
        function updateRequestHistory() {
            const historyDiv = document.getElementById('requestHistory');
            if (requestHistory.length === 0) {
                historyDiv.innerHTML = '<div class="status info">No requests sent yet.</div>';
                return;
            }

            historyDiv.innerHTML = requestHistory.map((item, index) => {
                const time = new Date(item.timestamp).toLocaleTimeString();
                const itemClass = item.success ? 'success' : 'error';
                let content = `
                    <div class="request-item ${itemClass}">
                        <div class="request-time">${time} - ${item.url}</div>
                `;
                
                // Show if we switched from localhost to IP
                if (item.originalUrl && item.originalUrl !== item.url) {
                    content += `<div style="margin-top: 3px; font-size: 0.85em; color: #64b4ff;"><strong>Auto-switched:</strong> ${item.originalUrl} ‚Üí ${item.url}</div>`;
                }

                if (item.error) {
                    content += `<div><strong>Error:</strong> ${item.error}</div>`;
                    
                    // Display detailed error information if available
                    if (item.errorDetails) {
                        const details = item.errorDetails;
                        
                        if (details.name && details.name !== 'Error') {
                            content += `<div style="margin-top: 5px; font-size: 0.9em;"><strong>Error Type:</strong> ${details.name} (${details.type || 'Error'})</div>`;
                        }
                        
                        if (details.networkError) {
                            const isSSL = details.isSSLError;
                            content += `<div style="margin-top: 5px; font-size: 0.9em; ${isSSL ? 'color: #ffaa00; font-weight: bold;' : ''}"><strong>Network Error:</strong> ${details.networkError}</div>`;
                            if (details.networkErrorDetails && details.networkErrorDetails.length > 0) {
                                content += `<ul style="margin: 5px 0 5px 20px; font-size: 0.85em; color: #ccc;">`;
                                details.networkErrorDetails.forEach(detail => {
                                    const isSolution = detail.trim().startsWith('Solutions:') || detail.trim().match(/^\d+\./);
                                    const isCheckmark = detail.trim().startsWith('‚úì');
                                    content += `<li style="${isSolution ? 'font-weight: bold; color: #64b4ff; margin-top: 5px;' : isCheckmark ? 'color: #51cf66;' : ''}">${detail}</li>`;
                                });
                                content += `</ul>`;
                            }
                            
                            // Add certificate acceptance helper for SSL errors
                            if (isSSL && item.url.startsWith('https://')) {
                                content += `<div style="margin-top: 10px; padding: 8px; background: rgba(255, 170, 0, 0.1); border: 1px solid rgba(255, 170, 0, 0.3); border-radius: 4px;">`;
                                content += `<div style="font-size: 0.9em; margin-bottom: 8px;"><strong>‚ö†Ô∏è SSL Certificate Issue</strong></div>`;
                                content += `<div style="font-size: 0.85em; margin-bottom: 8px; color: #ccc;">To fix this, you need to accept the self-signed certificate first:</div>`;
                                content += `<ol style="font-size: 0.85em; margin: 0 0 8px 20px; color: #ccc; padding-left: 15px;">`;
                                content += `<li>Click the button below to open the server URL</li>`;
                                content += `<li>In the security warning, click "Advanced"</li>`;
                                content += `<li>Click "Proceed to site" (or similar)</li>`;
                                content += `<li>Come back and try the request again</li>`;
                                content += `</ol>`;
                                content += `<a href="${item.url}" target="_blank" style="display: inline-block; background: #667eea; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85em; text-decoration: none; margin-right: 8px;">Open ${item.urlDetails?.hostname || 'Server URL'}</a>`;
                                content += `<button onclick="sendTestRequest();" style="background: #51cf66; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Retry Request</button>`;
                                content += `</div>`;
                            }
                        }
                        
                        if (details.urlDetails) {
                            content += `<div style="margin-top: 5px; font-size: 0.9em;"><strong>URL Details:</strong> `;
                            if (details.urlDetails.error) {
                                content += `<span style="color: #ff6b6b;">${details.urlDetails.error}</span>`;
                            } else {
                                content += `${details.urlDetails.protocol}//${details.urlDetails.hostname}`;
                                if (details.urlDetails.port) {
                                    content += `:${details.urlDetails.port}`;
                                }
                                content += details.urlDetails.pathname;
                            }
                            content += `</div>`;
                        }
                        
                        if (details.payloadSize !== undefined) {
                            content += `<div style="margin-top: 5px; font-size: 0.9em;"><strong>Payload Size:</strong> ${details.payloadSize} bytes</div>`;
                        }
                        
                        if (details.stack) {
                            content += `<details style="margin-top: 5px; font-size: 0.85em;"><summary style="cursor: pointer; color: #b0c4ff;">Stack Trace</summary><pre style="margin-top: 5px; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow-x: auto; font-size: 0.8em;">${details.stack}</pre></details>`;
                        }
                    }
                } else {
                    content += `<div><strong>Status:</strong> ${item.status} ${item.statusText || ''}</div>`;
                    
                    // Show response details for failed requests
                    if (!item.success && item.response) {
                        if (item.response.error) {
                            const errorPreview = item.response.error.length > 200 
                                ? item.response.error.substring(0, 200) + '...' 
                                : item.response.error;
                            content += `<div style="margin-top: 5px; font-size: 0.9em;"><strong>Response:</strong> <pre style="display: inline; font-size: 0.85em; color: #ff6b6b;">${errorPreview}</pre></div>`;
                        }
                        if (item.response.rawResponse) {
                            const rawPreview = item.response.rawResponse.length > 200 
                                ? item.response.rawResponse.substring(0, 200) + '...' 
                                : item.response.rawResponse;
                            content += `<div style="margin-top: 5px; font-size: 0.9em;"><strong>Raw Response:</strong> <pre style="display: inline; font-size: 0.85em; color: #ccc;">${rawPreview}</pre></div>`;
                        }
                    }
                    
                    // Show response headers if available
                    if (item.responseHeaders && Object.keys(item.responseHeaders).length > 0) {
                        content += `<details style="margin-top: 5px; font-size: 0.85em;"><summary style="cursor: pointer; color: #b0c4ff;">Response Headers</summary><pre style="margin-top: 5px; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow-x: auto; font-size: 0.8em;">${JSON.stringify(item.responseHeaders, null, 2)}</pre></details>`;
                    }
                }

                if (item.response && item.response.avg_bpm_last_20s !== undefined) {
                    content += `<div><strong>Server avg_bpm_last_20s:</strong> ${item.response.avg_bpm_last_20s}</div>`;
                }

                content += `</div>`;
                return content;
            }).join('');
        }

        // Event listeners
        document.getElementById('refreshBtn').addEventListener('click', updateUI);
        document.getElementById('testSendBtn').addEventListener('click', sendTestRequest);
        document.getElementById('startListeningBtn').addEventListener('click', initializeBeatDetection);
        document.getElementById('stopListeningBtn').addEventListener('click', stopBeatDetection);

        document.getElementById('autoUpdate').addEventListener('change', (e) => {
            if (e.target.checked) {
                autoUpdateInterval = setInterval(updateUI, 500);
            } else {
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                }
            }
        });

        // Initialize
        window.addEventListener('load', async () => {
            updateUI();
            if (document.getElementById('autoUpdate').checked) {
                autoUpdateInterval = setInterval(updateUI, 500);
            }
            showListeningStatus('info', 'Click "Start Listening" to begin collecting audio data');
        });

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (autoUpdateInterval) {
                clearInterval(autoUpdateInterval);
            }
        });
    </script>
</body>
</html>

